=encoding UTF-8

=head1 Name

sqitchtutorial-firebird - A tutorial introduction to Sqitch change management on Firebird

=head1 Synopsis

  sqitch *

=head1 Description

This tutorial explains how to create a sqitch-enabled Firebird project, use a
VCS for deployment planning, and work with other developers to make sure
changes remain in sync and in the proper order.

We'll start by creating new project from scratch, a fictional antisocial
networking site called Flipr. All examples use L<Git|http://git-scm.com/> as
the VCS and L<Firebird|http://www.firebirdsql.org/> as the storage engine.

=head1 Starting a New Project

Usually the first thing to do when starting a new project is to create a
source code repository. So let's do that with Git:

  > mkdir flipr
  > cd flipr
  > git init .
  Initialized empty Git repository in /flipr/.git/
  > touch README.md
  > git add .
  > git commit -am 'Initialize project, add README.'
  [master (root-commit) dfadc74] Initialize project, add README.
  1 file changed, 0 insertions(+), 0 deletions(-)
  create mode 100644 README.md

If you're a Git user and want to follow along the history, the
repository used in these examples is L<on
GitHub|https://github.com/theory/sqitch-firebird-intro>.

=begin comment

TODO: create the repo on GitHub

=end comment

Now that we have a repository, let's get started with Sqitch. Every Sqitch
project must have a name associated with it, and, optionally, a unique URI. We
recommend including the URI, as it increases the uniqueness of object
identifiers internally, so let's specify one when we initialize Sqitch:

  > sqitch --engine firebird init flipr --uri https://github.com/theory/sqitch-firebird-intro/
  Created sqitch.conf
  Created sqitch.plan
  Created deploy/
  Created revert/
  Created verify/

Let's have a look at F<sqitch.conf>:

  > cat sqitch.conf
[core]
        engine = firebird
        # plan_file = sqitch.plan
        # top_dir = .
        # deploy_dir = deploy
        # revert_dir = revert
        # verify_dir = verify
        # extension = sql
# [core "firebird"]
        # client = /opt/firebird/bin/isql
	# uri = db:firebird:
	# registry = sqitch

Good, it picked up on the fact that we're creating changes for the
Firebird engine, thanks to the C<--engine firebird> option, and saved
it to the file.  Furthermore, it wrote a commented-out C<[core
"firebird"]> section with all the available Firebird engine-specific
settings commented out and ready to be edited as appropriate.

By default, Sqitch will read F<sqitch.conf> in the current directory for
settings. But it will also read F<~/.sqitch/sqitch.conf> for user-specific
settings.

The current implementation of the engine will try to find Firebird's
L<C<firebird> client|http://www.firebirdsql.org/manual/isql-commands.html>
(implemented for GNU/Linux and Microsoft Windows).  This might fail,
so we go ahead an tell it where to find the client on our computer,
for example on GNU/Linux with the standard location of the Firebird
installation the command is:

  > sqitch config --user core.firebird.client /opt/firebird/bin/isql

Note: On some GNU/Linux distributions the firebird client is renamed
to C<isql-fb>, for example in Debian and Fedora, or C<fbsql> in
Gentoo.

At this point we can save a lot of typing if we set up a target that
contains the username and the password. Sqitch uses URIs to determine
how to connect to the database, so let's give it a default URI, shall
we?

  > sqitch config core.firebird.dev.uri db:firebird://SYSDBA<mysecret>@localhost/

of course, you have to replace <mysecret> with "your secret" password.

The default database administrator name C<SYSDBA> can be replaced with
any other user with the proper privileges to create databases.

Because of the way how Firebird is designed we need to provide the
path to the databases.  The C<flipr_test.fdb> database have to exist,
the C<sqitch.fdb> database will be created if it doesn't exists.

And let's also tell it who we are, since this data will be used in all
of our projects:

  > sqitch config --user user.name 'Marge N. O’Vera'
  > sqitch config --user user.email 'marge@example.com'

Have a look at F<~/.sqitch/sqitch.conf> and you'll see something like
this:

  > cat ~/.sqitch/sqitch.conf
  [core "firebird"]
    client = /opt/local/bin/isql
  [user]
    name = Marge N. O’Vera
    email = marge@example.com

Which means that Sqitch should be able to find C<isql> for any project, and
that it will always properly identify us when planning and committing changes.

Back to the repository. Have a look at the plan file, F<sqitch.plan>:

  > cat sqitch.plan
  %syntax-version=1.0.0-b2
  %project=flipr
  %uri=https://github.com/theory/sqitch-firebird-intro/


Note that it has picked up on the name and URI of the app we're building.
Sqitch uses this data to manage cross-project dependencies. The
C<%syntax-version> pragma is always set by Sqitch, so that it always knows how
to parse the plan, even if the format changes in the future.

Let's commit these changes and start creating the database changes.

  > git add .
  > git commit -am 'Initialize Sqitch configuration.'
  [master 1b5ee59] Initialize Sqitch configuration.
  2 files changed, 23 insertions(+)
  create mode 100644 sqitch.conf
  create mode 100644 sqitch.plan

Let's create our flipr test database using C<isql>:

  > /opt/firebird/bin/isql -u SYSDBA -p <mysecret>
  Use CONNECT or CREATE DATABASE to specify a database
  SQL> CREATE DATABASE '/home/fbdb/flipr_test.fdb';
  SQL> exit;

=head1 Our First Change

Let's create a table. Our app will need users, of course, so we'll create a
table for them. Run this command:

  > sqitch add users -n 'Creates table to track our users.'
  Created deploy/users.sql
  Created revert/users.sql
  Created verify/users.sql
  Added "users" to sqitch.plan

The L<C<add>|sqitch-add> command adds a database change to the plan and writes
deploy, revert, and verify scripts that represent the change. Now we edit
these files. The C<deploy> script's job is to create the table. By default,
the F<deploy/users.sql> file looks like this:

  -- Deploy users

  -- XXX Add DDLs here.

  COMMIT;

What we want to do is to replace the C<XXX> comment with the C<CREATE TABLE>
statement, like so:

  -- Deploy users

  CREATE TABLE users (
      nickname  VARCHAR(50)  PRIMARY KEY,
      password  VARCHAR(512) NOT NULL,
      fullname  VARCHAR(512) NOT NULL,
      twitter   VARCHAR(512) NOT NULL,
      timestmp  TIMESTAMP    DEFAULT CURRENT_TIMESTAMP
  );

  COMMIT;

The C<revert> script's job is to precisely revert the change to the deploy
script, so we edit this to F<revert/users.sql> to look like this:

  -- Revert users

  DROP TABLE users;

  COMMIT;

Now we can try deploying this change:


  > sqitch --db-name /home/fbdb/flipr_test.fdb deploy
  Adding registry tables to /home/fbdb/sqitch.fdb
  Deploying changes to /home/fbdb/flipr_test.fdb
    + users .. ok

First Sqitch created the registry database and tables used to track
database changes. The registry is separate from the database to which
the C<users> change was deployed; by default, its name is
C<sqitch.$suffix>, where C<$suffix> is the same as the suffix on the
target database, if any. It lives in the same directory as the target
database, which means that one registry database is used for all the
databases with the same suffix in a single directory.

If you'd like it to have a different name for the registry database,
set it up via the C<core.firebird.registry> configuration variable:

  > sqitch config core.firebird.registry /home/fbdb/flipr_sqitch.fdb

This will be useful if you don't want to use the same registry
database to manage multiple databases, or if you do, but they live in
different directories.

Ideally, only Sqitch data will be stored in this database, so it probably makes
the most sense to create a superuser named C<sqitch> or something similar and
use it to deploy changes.

Next, Sqitch deploys changes to the target database.  We only have one
change so far; the C<+> reinforces the idea that the change is being
I<added> to the database.

With this change deployed, if you connect to the database, you'll be able to
see the schema:

  > /opt/firebird/bin/isql -u SYSDBA -p <mysecret>
  Use CONNECT or CREATE DATABASE to specify a database
  SQL> connect '/home/fbdb/flipr_test.fdb';
  Database:  '/home/fbdb/flipr_test.fdb', User: SYSDBA
  SQL> show tables;
       USERS
  SQL> quit;

=head2 Trust, But Verify

But that's too much work. do you really want to do something like that after
every deploy?

Here's where the C<verify> script comes in. Its job is to test that the deploy
did was it was supposed to. It should do so without regard to any data that
might be in the database, and should throw an error if the deploy was not
successful. The easiest way to do that with a table is to simply C<SELECT>
from it. Put this query into F<verify/users.sql>:

  SELECT nickname, password, fullname, twitter
    FROM users
   WHERE 1=2;

Now you can run the C<verify> script with the L<C<verify>|sqitch-verify>
command:

  > sqitch --db-name /home/fbdb/flipr_test.fdb verify
  Verifying flipr_test.db
    * users .. ok
  Verify successful

Looks good! If you want to make sure that the verify script correctly dies if
the table doesn't exist, temporarily change the table name in the script to
something that doesn't exist, something like:

  SELECT nickname, password, timestmp
    FROM users_nonesuch
   WHERE 1=2;

Then L<C<verify>|sqitch-verify> again:

  > sqitch --db-name /home/fbdb/flipr_test.fdb verify
  Verifying /home/fbdb/flipr_test.fdb
    * users .. Statement failed, SQLSTATE = 42S02
  Dynamic SQL Error
  -SQL error code = -204
  -Table unknown
  -USERS_NONESUCH
  -At line 3, column 2
  At line 3 in file verify/users.sql
  # Verify script "verify/users.sql" failed.
  not ok

  Verify Summary Report
  ---------------------
  Changes: 1
  Errors:  1
  Verify failed


Firebird is kind enough to tell us what the problem is. Don't forget to change
the table name back before continuing!

=head2 Status, Revert, Log, Repeat

For purely informational purposes, we can always see how a deployment was
recorded via the L<C<status>|sqitch-status> command, which reads the tables
from the registry database:

  > sqitch --db-name /home/fbdb/flipr_test.fdb status
  # On database /home/fbdb/flipr_test.fdb
  # Project:  flipr
  # Change:   a701b93e92481c3f19336f1f17920c1c965cc730
  # Name:     users
  # Deployed: 2013-11-08 20:50:01 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  #
  Nothing to deploy (up-to-date)


Let's make sure that we can revert the change:

  > sqitch --db-name /home/fbdb/flipr_test.fdb revert
  Revert all changes from flipr_test.fdb? [Yes]
    - users .. ok

The L<C<revert>|sqitch-revert> command first prompts to make sure that we
really do want to revert. This is to prevent unnecessary accidents. You can
pass the C<-y> option to disable the prompt. Also, notice the C<-> before the
change name in the output, which reinforces that the change is being
I<removed> from the database. And now the schema should be gone:

  > /opt/firebird/bin/isql -u SYSDBA -p <mysecret>
  Use CONNECT or CREATE DATABASE to specify a database
  SQL> connect '/home/fbdb/flipr_test.fdb';
  Database:  '/home/fbdb/flipr_test.fdb', User: SYSDBA
  SQL> show tables;
  There are no tables in this database
  SQL> quit;

And the status message should reflect as much:

  > sqitch --db-name /home/fbdb/flipr_test.fdb status
  # On database /home/fbdb/flipr_test.fdb
  No changes deployed

Of course, since nothing is deployed, the L<C<verify>|sqitch-verify> command
has nothing to verify:

  > sqitch --db-name /home/fbdb/flipr_test.fdb verify
  Verifying /home/fbdb/flipr_test.fdb
  No changes deployed

However, we still have a record that the change happened, visible via the
L<C<log>|sqitch-log> command:

  > sqitch --db-name /home/fbdb/flipr_test.fdb log
  # On database /home/fbdb/flipr_test.fdb
  Verifying /home/fbdb/flipr_test.fdb
  On database /home/fbdb/flipr_test.fdb
  Revert a701b93e92481c3f19336f1f17920c1c965cc730
  Name:      users
  Committer: Marge N. O’Vera <marge@example.com>
  Date:      2013-11-08 20:50:02 +0200

      Creates table to track our users.

  Deploy a701b93e92481c3f19336f1f17920c1c965cc730
  Name:      users
  Committer: Marge N. O’Vera <marge@example.com>
  Date:      2013-11-08 20:50:01 +0200

      Creates table to track our users.


Note that the actions we took are shown in reverse chronological
order, with the revert first and then the deploy.

And then deploy again.  This time, let's use the C<--verify> option,
so that the C<verify> script is applied when the change is deployed:

  > sqitch --db-name /home/fbdb/flipr_test.fdb deploy --verify
  Deploying changes to /home/fbdb/flipr_test.fdb
    + users .. ok

And now the C<users> table should be back:

  > /opt/firebird/bin/isql -u SYSDBA -p <mysecret>
  Use CONNECT or CREATE DATABASE to specify a database
  SQL> connect '/home/fbdb/flipr_test.fdb';
  Database:  '/home/fbdb/flipr_test.fdb', User: SYSDBA
  SQL> show tables;
       USERS
  SQL> quit;

When we look at the status, the deployment will be there:
  > sqitch --db-name /home/fbdb/flipr_test.fdb status
  # On database /home/fbdb/flipr_test.fdb
  # Project:  flipr
  # Change:   a701b93e92481c3f19336f1f17920c1c965cc730
  # Name:     users
  # Deployed: 2013-11-08 20:50:05 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  #
  Nothing to deploy (up-to-date)


=head1 More Configuration

Let's also make sure that changes are verified after deploying them:

  > sqitch config --bool deploy.verify true
  > sqitch config --bool rebase.verify true

We'll see the L<C<rebase>|sqitch-rebase> command a bit later.  In the
meantime, let's commit the new configuration and and make some more
changes!

  > git commit -am 'Set default DB name and always verify.'
  [master 2be895b] Set default DB name and always verify.
   2 files changed, 6 insertions(+), 1 deletion(-)


=head1 Deploy with Dependency

Let's add another change.  Our app will need to store status messages
from users. Let's call them -- and the table to store them --
"flips". First, add the new change:

  > sqitch add flips --requires users -n 'Adds table for storing flips.'
  Created deploy/flips.sql
  Created revert/flips.sql
  Created verify/flips.sql
  Added "flips [users]" to sqitch.plan

Note that we're requiring the C<users> change as a dependency of the new
C<flips> change. Although that change has already been added to the plan and
therefore should always be applied before the C<flips> change, it's a good
idea to be explicit about dependencies.

Now edit the scripts.  When you're done, F<deploy/flips.sql> should
look like this:

  -- Deploy flips
  -- requires: users

  CREATE TABLE flips (
      id        INTEGER       NOT NULL PRIMARY KEY,
      nickname  VARCHAR(50)   NOT NULL REFERENCES users(nickname),
      body      VARCHAR(512)  NOT NULL CHECK ( char_length(body) <= 180 ),
      timestmp  TIMESTAMP     DEFAULT CURRENT_TIMESTAMP
  );

  COMMIT;

A couple things to notice here.  On the second line, the dependence on
the C<users> change has been listed.  This doesn't do anything, but
the default C<deploy> template lists it here for your reference while
editing the file.  Useful, right?

The C<users.nickname> column references the C<users> table.  This is
why we need to require the C<users> change.

Now for the verify script. Again, all we need to do is C<SELECT> from
the table.  I recommend selecting each column by name, too, to be sure
that no column is missing.  Here's the F<verify/flips.sql>:

  -- Verify flips

  SELECT id, nickname, body, timestmp
    FROM flips
    WHERE 1=2;

  COMMIT;

Now for the revert script: all we have to do is drop the table. Add this to
F<revert/flips.sql>:

  -- Revert flips

  DROP TABLE flips;

  COMMIT;

Couldn't be much simpler, right? Let's deploy this bad boy:

  > sqitch --db-name /home/fbdb/flipr_test.fdb deploy
  Deploying changes to flipr_test.fdb
    + flips .. ok

We know, since verification is enabled, that the table must have been created.
But for the purposes of visibility, let's have a quick look:


  > /opt/firebird/bin/isql -u SYSDBA -p <mysecret>
  Use CONNECT or CREATE DATABASE to specify a database
  SQL> connect '/home/fbdb/flipr_test.fdb';
  Database:  '/home/fbdb/flipr_test.fdb', User: SYSDBA
  SQL> show tables;
         FLIPS                                  USERS

  SQL> quit;

We can also verify all currently deployed changes with the
L<C<verify>|sqitch-verify> command:

  > sqitch --db-name /home/fbdb/flipr_test.fdb verify
  Verifying flipr_test.db
    * users .. ok
    * flips .. ok
  Verify successful

Now have a look at the status:

  > sqitch --db-name /home/fbdb/flipr_test.fdb status
  # On database /home/fbdb/flipr_test.fdb
  # Project:  flipr
  # Change:   51a52966c2a47f8899f9609ce4b1b9b956a3ec56
  # Name:     flips
  # Deployed: 2013-11-08 20:50:08 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  #
  Nothing to deploy (up-to-date)


Success! Let's make sure we can revert the change, as well:

  > sqitch --db-name /home/fbdb/flipr_test.fdb revert --to @HEAD^ -y
    Reverting changes to users from /home/fbdb/flipr_test.fdb
  - flips .. ok

Note that we've used the C<--to> option to specify the change to
revert to.  And what do we revert to? The symbolic tag C<@HEAD>, when
passed to L<C<revert>|sqitch-revert>, always refers to the last change
deployed to the database.  (For other commands, it refers to the last
change in the plan.)  Appending the caret (C<^>) tells Sqitch to
select the change I<prior> to the last deployed change.  So we revert
to C<users>, the penultimate change.  The other potentially useful
symbolic tag is C<@ROOT>, which refers to the first change deployed to
the database (or in the plan, depending on the command).

Back to the database. The C<flips> table should be gone but the
C<users> table should still be around:

  > /opt/firebird/bin/isql -u SYSDBA -p <mysecret>
  Use CONNECT or CREATE DATABASE to specify a database
  SQL> connect '/home/fbdb/flipr_test.fdb';
  Database:  '/home/fbdb/flipr_test.fdb', User: SYSDBA
  SQL> show tables;
       USERS
  SQL> quit;

The L<C<status>|sqitch-status> command politely informs us that we have
undeployed changes:

  > sqitch --db-name /home/fbdb/flipr_test.fdb status
  # On database /home/fbdb/flipr_test.fdb
  # Project:  flipr
  # Change:   a701b93e92481c3f19336f1f17920c1c965cc730
  # Name:     users
  # Deployed: 2013-11-08 20:50:05 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  #
  Undeployed change:
    * flips


As does the L<C<verify>|sqitch-verify> command:

  > sqitch --db-name /home/fbdb/flipr_test.fdb verify
  Verifying /home/fbdb/flipr_test.fdb
    * users .. ok
  Undeployed change:
    * flips
  Verify successful

Note that the verify is successful, because all currently-deployed
changes are verified.  The list of undeployed changes (just "flips"
here) reminds us about the current state.

Okay, let's commit and deploy again:

  > git add .
  > git commit -am 'Add flips table.'
  [master 5e04f7f] Add flips table.
   4 files changed, 30 insertions(+)
   create mode 100644 deploy/flips.sql
   create mode 100644 revert/flips.sql
   create mode 100644 verify/flips.sql
  > sqitch --db-name /home/fbdb/flipr_test.fdb deploy
  Deploying changes to flipr_test.db
    + flips .. ok

Looks good. Check the status:

  > sqitch --db-name /home/fbdb/flipr_test.fdb status
  # On database /home/fbdb/flipr_test.fdb
  # Project:  flipr
  # Change:   51a52966c2a47f8899f9609ce4b1b9b956a3ec56
  # Name:     flips
  # Deployed: 2013-11-08 20:50:12 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  #
  Nothing to deploy (up-to-date)


=head1 View to a Thrill

One more thing to add before we are ready to ship a first beta release. Let's
create a view that lists user names with their flips.

  > sqitch add userflips --requires users --requires flips \
    -n 'Creates the userflips view.'
  Created deploy/userflips.sql
  Created revert/userflips.sql
  Created verify/userflips.sql
  Added "userflips [users flips]" to sqitch.plan

Now add this SQL to F<deploy/userflips.sql>:

  CREATE VIEW userflips AS
  SELECT f.id, u.nickname, u.fullname, f.body, f.timestmp
    FROM users u
    JOIN flips f ON u.nickname = f.nickname;

Add this SQL to F<verify/userflips.sql>

  SELECT id, nickname, fullname, body, timestmp
    FROM userflips
   WHERE 1=2;

And add the C<DROP VIEW> statement to F<revert/userflips.sql>:

  DROP VIEW userflips;

Now Try it out!

  > sqitch --db-name /home/fbdb/flipr_test.fdb deploy
  Deploying changes to /home/fbdb/flipr_test.fdb
    + userflips .. ok
  > sqitch --db-name /home/fbdb/flipr_test.fdb revert -y
  Reverting all changes from /home/fbdb/flipr_test.fdb
    - userflips .. ok
    - flips ...... ok
    - users ...... ok
  > sqitch --db-name /home/fbdb/flipr_test.fdb deploy
  Deploying changes to /home/fbdb/flipr_test.fdb
    + users ...... ok
    + flips ...... ok
    + userflips .. ok


Looks good! Commit it.

  > git add .
  > git commit -m 'Add the userflips view.'
  [master f76f6e7] Add the userflips view.
   4 files changed, 29 insertions(+)
   create mode 100644 deploy/userflips.sql
   create mode 100644 revert/userflips.sql
   create mode 100644 verify/userflips.sql

=head1 Ship It!

Let's do a first release of our app.  Let's call it C<1.0.0-dev1>.
Since we want to have it go out with deployments tied to the release,
let's tag it:

  > sqitch tag v1.0.0-dev1 -n 'Tag v1.0.0-dev1.'
  Tagged "change_pass" with @v1.0.0-dev1
  > git commit -am 'Tag the database with v1.0.0-dev1.'
  [master 384543e] Tag the database with v1.0.0-dev1.
   1 file changed, 1 insertion(+)
  > git tag v1.0.0-dev1 -am 'Tag v1.0.0-dev1'

Now let's bundle everything up for release:

  > sqitch bundle
  Bundling into bundle
  Writing config
  Writing plan
  Writing scripts
    + users
    + flips
    + userflips @v1.0.0-dev1

Now we can package the F<bundle> directory and distribute it.  When it
gets installed somewhere, users can use Sqitch to deploy to the
database.

Now we can try deploying the bundle, but first let's create the C<dev>
database:

  > /opt/firebird/bin/isql -u SYSDBA -p <mysecret>
  Use CONNECT or CREATE DATABASE to specify a database
  SQL> CREATE DATABASE '/home/fbdb/flipr_dev.fdb';
  SQL> exit;

We can try deploying to make sure the tag gets picked up like so:

  > sqitch -d /home/fbdb/flipr_dev.fdb deploy
  Adding registry tables to /home/fbdb/sqitch-flipr_dev.fdb
  Deploying changes to /home/fbdb/flipr_dev.fdb
    + users ................... ok
    + flips ................... ok
    + userflips @v1.0.0-dev1 .. ok

Great, both changes were deployed and C<userflips> was tagged with
C<@v1.0.0-dev1>. Let's have a look at the status:

  > sqitch -d /home/fbdb/flipr_dev.fdb status
  # On database /home/fbdb/flipr_dev.fdb
  # Project:  flipr
  # Change:   840f8284a4d4528123ee701b40dbe7efc3c892f8
  # Name:     userflips
  # Tag:      @v1.0.0-dev1
  # Deployed: 2013-11-08 20:50:26 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  #
  Nothing to deploy (up-to-date)


Note the listing of the tag as part of the status message.

Package it up and ship it!

  > cd ..
  > mv bundle flipr-v1.0.0-dev1
  > tar -czf flipr-v1.0.0-dev1.tgz flipr-v1.0.0-dev1

=head1 Making a Hash of Things

Now that we've got the basics of the app done, let's add a feature. Gotta
track the hashtags associated with flips, right? Let's add a table for them.
But since other folks are working on other tasks in the repository, we'll work
on a branch, so we can all stay out of each other's way. So let's branch:

  > git checkout -b hashtags
  Switched to a new branch 'hashtags'

Now we can add a new change to create a table for hashtags.

  > sqitch add hashtags --requires flips -n 'Adds table for storing hashtags.'
  Created deploy/hashtags.sql
  Created revert/hashtags.sql
  Created verify/hashtags.sql
  Added "hashtags [flips]" to sqitch.plan

You know the drill by now. Add this to F<deploy/hashtags.sql>

  CREATE TABLE hashtags (
      flip_id   INTEGER      NOT NULL REFERENCES flips(id),
      hashtag   VARCHAR(512) NOT NULL CHECK(char_length(hashtag) > 0),
      PRIMARY KEY (flip_id, hashtag)
  );

Again, select from the table in F<verify/hashtags.sql>:

  SELECT flip_id, hashtag FROM hashtags WHERE 1=2;

And drop it in F<revert/hashtags.sql>

  DROP TABLE hashtags;

And give it a whirl:

  > sqitch -d /home/fbdb/flipr_test.fdb deploy
  Deploying changes to flipr_test.db
    + hashtags .. ok

Look good?

  > sqitch -d /home/fbdb/flipr_test.fdb status --show-tags
  # On database /home/fbdb/flipr_test.fdb
  # Project:  flipr
  # Change:   e9cbeae58ababce19c86877f89de0ffdc568f9ed
  # Name:     hashtags
  # Deployed: 2013-11-08 20:50:29 +0200
  # By:       Marge N. O’Vera <marge@example.com>
  #
  # Tag:
  #   @v1.0.0-dev1 - 2013-11-08 20:50:28 +0200 - Marge N. O’Vera <marge@example.com>
  #
  Nothing to deploy (up-to-date)


Note the use of C<--show tags> to show all the deployed tags. Now make it so:

  > git add .
  > git commit -am 'Add hashtags table.'
  [hashtags ad40ccd] Add hashtags table.
   4 files changed, 28 insertions(+)
   create mode 100644 deploy/hashtags.sql
   create mode 100644 revert/hashtags.sql
   create mode 100644 verify/hashtags.sql

Good, we've finished this feature. Time to merge back into C<master>.


=head2 Emergency

Let's do it:

  > git checkout master
  Switched to branch 'master'
  > git pull
  Updating 2db2775..e210a72
  Fast-forward
   deploy/lists.sql | 13 +++++++++++++
   revert/lists.sql |  7 +++++++
   sqitch.plan      |  2 ++
   verify/lists.sql |  9 +++++++++
   4 files changed, 31 insertions(+)
   create mode 100644 deploy/lists.sql
   create mode 100644 revert/lists.sql
   create mode 100644 verify/lists.sql

Hrm, that's interesting. Looks like someone made some changes to C<master>.
They added list support. Well, let's see what happens when we merge our
changes.

  > git merge --no-ff hashtags
  Auto-merging sqitch.plan
  CONFLICT (content): Merge conflict in sqitch.plan
  Automatic merge failed; fix conflicts and then commit the result.

Oh, a conflict in F<sqitch.plan>. Not too surprising, since both the merged
C<lists> branch and our C<hashtags> branch added changes to the plan. Let's
try a different approach.

The truth is, we got lazy. Those changes when we pulled master from the origin
should have raised a red flag. It's considered a bad practice not to look at
what's changed in C<master> before merging in a branch. What one I<should> do
is either:

=over

=item *

Rebase the F<hashtags> branch from master before merging. This "rewinds" the
branch changes, pulls from C<master>, and then replays the changes back on top
of the pulled changes.

=item *

Create a patch and apply I<that> to master. This is the sort of thing you
might have to do if you're sending changes to another user, especially if the
VCS is not Git.

=back

So let's restore things to how they were at master:

  > git reset --hard HEAD
  HEAD is now at d5e7e86 Merge branch 'lists'

That throws out our botched merge. Now let's go back to our branch and rebase
it on C<master>:

  > git checkout hashtags
  Switched to branch 'hashtags'
  > git rebase master
  First, rewinding head to replay your work on top of it...
  Applying: Add hashtags table.
  Using index info to reconstruct a base tree...
  M sqitch.plan
  Falling back to patching base and 3-way merge...
  Auto-merging sqitch.plan
  CONFLICT (content): Merge conflict in sqitch.plan
  Failed to merge in the changes.
  Patch failed at 0001 Add hashtags table.
  The copy of the patch that failed is found in:
     .git/rebase-apply/patch

  When you have resolved this problem, run "git rebase --continue".
  If you prefer to skip this patch, run "git rebase --skip" instead.
  To check out the original branch and stop rebasing, run "git rebase --abort".

Oy, that's kind of a pain. It seems like no matter what we do, we'll need to
resolve conflicts in that file. Except in Git. Fortunately for us, we can tell
Git to resolve conflicts in F<sqitch.plan> differently. Because we only ever
append lines to the file, we can have it use the "union" merge driver, which,
according to L<its
docs|http://git-scm.com/docs/gitattributes#_built-in_merge_drivers>:

=over

Run 3-way file level merge for text files, but take lines from both versions,
instead of leaving conflict markers. This tends to leave the added lines in
the resulting file in random order and the user should verify the result. Do
not use this if you do not understand the implications.

=back

This has the effect of appending lines from all the merging files, which is
exactly what we need. So let's give it a try. First, back out the botched
rebase:

  > git rebase --abort

Now add the union merge driver to F<.gitattributes> for F<sqitch.plan>
and rebase again:

  > echo sqitch.plan merge=union > .gitattributes
  > git rebase master
  First, rewinding head to replay your work on top of it...
  Applying: Add hashtags table.
  Using index info to reconstruct a base tree...
  M sqitch.plan
  Falling back to patching base and 3-way merge...
  Auto-merging sqitch.plan

Ah, that looks a bit better. Let's have a look at the plan:

  > cat sqitch.plan
  %syntax-version=1.0.0-b2
  %project=flipr
  %uri=https://github.com/theory/sqitch-firebird-intro/

  users 2013-11-08T20:15:55Z Marge N. O’Vera <marge@example.com> # Creates table to track our users.
  flips [users] 2013-11-08T20:21:23Z Marge N. O’Vera <marge@example.com> # Adds table for storing flips.
  userflips [users flips] 2013-11-08T20:28:13Z Marge N. O’Vera <marge@example.com> # Creates the userflips view.
  @v1.0.0-dev1 2013-11-08T20:36:13Z Marge N. O’Vera <marge@example.com> # Tag v1.0.0-dev1.

  lists [users] 2013-11-08T20:41:21Z Marge N. O’Vera <marge@example.com> # Adds table for storing lists.
  hashtags [flips] 2013-11-08T20:43:26Z Marge N. O’Vera <marge@example.com> # Adds table for storing hashtags.

Note that it has appended the changes from the merged "lists" branch, and then
merged the changes from our "hashtags" branch. Test it to make sure it works
as expected:

  > sqitch -d /home/fbdb/flipr_test.fdb rebase -y
  Reverting all changes from flipr_test.db
    - hashtags ................ ok
    - userflips @v1.0.0-dev1 .. ok
    - flips ................... ok
    - users ................... ok
  Deploying changes to flipr_test.db
    + users ................... ok
    + flips ................... ok
    + userflips @v1.0.0-dev1 .. ok
    + lists ................... ok
    + hashtags ................ ok

Note the use of L<C<rebase>|sqitch-rebase>, which combines a
L<C<revert>|sqitch-revert> and a L<C<deploy>|sqitch-deploy> into a single
command. Handy, right? It correctly reverted our changes, and then deployed
them all again in the proper order. So let's commit F<.gitattributes>; seems
worthwhile to keep that change:

  > git add .
  > git commit -m 'Add `.gitattributes` with union merge for `sqitch.plan`.'
  [hashtags 5c1fb6d] Add `.gitattributes` with union merge for `sqitch.plan`.
   1 file changed, 1 insertion(+)
   create mode 100644 .gitattributes

=head2 Merges Mastered

And now, finally, we can merge into C<master>:

  > git checkout master
  Switched to branch 'master'
  > git merge --no-ff hashtags -n "Merge branch 'hashtags'"
  Merge made by the 'recursive' strategy.
   .gitattributes      |  1 +
   deploy/hashtags.sql | 12 ++++++++++++
   revert/hashtags.sql |  7 +++++++
   sqitch.plan         |  1 +
   verify/hashtags.sql |  7 +++++++
   5 files changed, 28 insertions(+)
   create mode 100644 .gitattributes
   create mode 100644 deploy/hashtags.sql
   create mode 100644 revert/hashtags.sql
   create mode 100644 verify/hashtags.sql

And double-check our work:

  > cat sqitch.plan
  %syntax-version=1.0.0-b2
  %project=flipr
  %uri=https://github.com/theory/sqitch-firebird-intro/

  users 2013-11-08T20:15:55Z Marge N. O’Vera <marge@example.com> # Creates table to track our users.
  flips [users] 2013-11-08T20:21:23Z Marge N. O’Vera <marge@example.com> # Adds table for storing flips.
  userflips [users flips] 2013-11-08T20:28:13Z Marge N. O’Vera <marge@example.com> # Creates the userflips view.
  @v1.0.0-dev1 2013-11-08T20:36:13Z Marge N. O’Vera <marge@example.com> # Tag v1.0.0-dev1.

  lists [users] 2013-11-08T20:41:21Z Marge N. O’Vera <marge@example.com> # Adds table for storing lists.
  hashtags [flips] 2013-11-08T20:43:26Z Marge N. O’Vera <marge@example.com> # Adds table for storing hashtags.

Much much better, a nice clean master now. And because it is now identical to
the "hashtags" branch, we can just carry on. Go ahead and tag it, bundle, and
release:

  > sqitch tag v1.0.0-dev2 -n 'Tag v1.0.0-dev2.'
  Tagged "hashtags" with @v1.0.0-dev2
  > git commit -am 'Tag the database with v1.0.0-dev2.'
  [master 1edf584] Tag the database with v1.0.0-dev2.
   1 file changed, 1 insertion(+)
  > git tag v1.0.0-dev2 -am 'Tag v1.0.0-dev2'
  > sqitch bundle --dest-dir flipr-1.0.0-dev2
  Bundling into flipr-1.0.0-dev2
  Writing config
  Writing plan
  Writing scripts
    + users
    + flips
    + userflips @v1.0.0-dev1
    + lists
    + hashtags @v1.0.0-dev2

Note the use of the C<--dest-dir> option to C<sqitch bundle>. Just a nicer way
to create the top-level directory name so we don't have to rename it from
F<bundle>.

=head1 In Place Changes

Well, some folks have been testing the C<1.0.0-dev2> release and have demanded
that Twitter user links be added to Flipr pages. Why anyone would want to
include social network links in an anti-social networking app is beyond us
programmers, but we're just the plumbers, right? Gotta go with what Marketing
demands. The upshot is that we need to update the C<userflips> view, which is
used for the feature in question, to include the Twitter user names.

Normally, modifying views in database changes is a
L<PITA|http://www.urbandictionary.com/define.php?term=pita>. You have to make
changes like these:

=over

=item 1.

Copy F<deploy/userflips.sql> to F<deploy/userflips_twitter.sql>.

=item 2.

Edit F<deploy/userflips_twitter.sql> to re-create the view with the
new C<twitter> column added to the view.

=item 3.

Copy F<deploy/userflips.sql> to F<revert/userflips_twitter.sql>.
Yes, copy the original change script to the new revert change.

=item 4.

Add a C<DROP VIEW> statement to F<revert/userflips_twitter.sql>.

=item 5.

Copy F<verify/userflips.sql> to F<verify/userflips_twitter.sql>.

=item 6.

Modify F<verify/userflips_twitter.sql> to include a check for the C<twiter>
column.

=item 7.

Test the changes to make sure you can deploy and revert the
C<userflips_twitter> change.

=back

But you can have Sqitch do most of the work for you.  The only requirement is
that a tag appear between the two instances of a change we want to modify. In
general, you're going to make a change like this after a release, which you've
tagged anyway, right? Well we have, with C<@v1.0.0-dev2> added in the previous
section. With that, we can let Sqitch do most of the hard work for us, thanks
to the L<C<rework>|sqitch-rework> command, which is similar to
L<C<add>|sqitch-add>:

  > sqitch rework userflips -n 'Adds userflips.twitter.'
  Added "userflips [userflips@v1.0.0-dev2]" to sqitch.plan.
  Modify these files as appropriate:
    * deploy/userflips.sql
    * revert/userflips.sql
    * verify/userflips.sql


Oh, so we can edit those files in place. Nice! How does Sqitch do it? Well, in
point of fact, it has copied the files to stand in for the previous instance
of the C<userflips> change, which we can see via C<git status>:

  > git status
  # On branch master
  # Changes not staged for commit:
  #   (use "git add <file>..." to update what will be committed)
  #   (use "git checkout -- <file>..." to discard changes in working directory)
  #
  # modified:   revert/userflips.sql
  # modified:   sqitch.plan
  #
  # Untracked files:
  #   (use "git add <file>..." to include in what will be committed)
  #
  # deploy/userflips@v1.0.0-dev2.sql
  # revert/userflips@v1.0.0-dev2.sql
  # verify/userflips@v1.0.0-dev2.sql
  no changes added to commit (use "git add" and/or "git commit -a")

The "untracked files" part of the output is the first thing to notice. They
are all named C<userflips@v1.0.0-dev2.sql>.  What that means is: "the
C<userflips> change as it was implemented as of the C<@v1.0.0-dev2> tag."
These are copies of the original scripts, and thereafter Sqitch will find them
when it needs to run scripts for the first instance of the C<userflips>
change. As such, it's important not to change them again. But hey, if you're
reworking the change, you shouldn't need to.

The other thing to notice is that F<revert/userflips.sql> has changed. Sqitch
replaced it with the original deploy script.  As of now,
F<deploy/userflips.sql> and F<revert/userflips.sql> are identical.  This is on
the assumption that the deploy script will be changed (we're reworking it,
remember?), and that the revert script should actually change things back to
how they were before.

Fortunately, our view deploy scripts are already
L<idempotent|http://en.wikipedia.org/wiki/Idempotence> -- that is,
able to be applied multiple times without changing the result beyond
the initial application use, thanks to the Firebird's support for the
C<CREATE OR ALTER VIEW> expression.  No matter how many times a
deployment script is run, the end result will be the same instance of
the view, with no duplicates or errors.

Modify F<deploy/userflips.sql> to add the C<twitter> column; and also
use the C<OR ALTER> statement:

  @@ -4,8 +4,9 @@

  -CREATE VIEW userflips AS
  +CREATE OR ALTER VIEW userflips AS
  -SELECT f.id, u.nickname, u.fullname, f.body, f.timestmp
  +SELECT f.id, u.nickname, u.fullname, u.twitter, f.body, f.timestmp
     FROM users u
     JOIN flips f ON u.nickname = f.nickname;

Next, modify F<verify/userflips.sql> to check for the C<twitter> column.
Here's the diff:

  @@ -2,7 +2,7 @@

  -SELECT id, nickname, fullname, body, timestmp
  +SELECT id, nickname, fullname, twitter, body, timestmp
     FROM userflips
    WHERE 1=2;

And finally, modify F<deploy/userflips@v1.0.0-dev2.sql> to add the
C<OR ALTER> statement:

  @@ -4,6 +4,7 @@

   -CREATE VIEW userflips AS
   +CREATE OR ALTER VIEW userflips AS
   SELECT f.id, u.nickname, u.fullname, f.body, f.timestmp
     FROM users u

Note that if we had included that statement when we originally created the
C<userflips> change, we wouldn't have to change this file at all.

Now try a deployment:

  > sqitch -d /home/fbdb/flipr_test.fdb deploy
  Deploying changes to /home/fbdb/flipr_test.db
    + userflips .. ok

So, are the changes deployed?

  > /opt/firebird/bin/isql -u SYSDBA -p <mysecret>
  Use CONNECT or CREATE DATABASE to specify a database
  SQL> connect '/home/fbdb/flipr_test.fdb';
  Database:  '/home/fbdb/flipr_test.fdb', User: SYSDBA
  SQL> show table users;
  NICKNAME                        VARCHAR(50) Not Null
  PASSWORD                        VARCHAR(512) Not Null
  FULLNAME                        VARCHAR(512) Not Null
  TWITTER                         VARCHAR(512) Not Null
  TIMESTMP                        TIMESTAMP Nullable DEFAULT CURRENT_TIMESTAMP

  CONSTRAINT INTEG_24:
  Primary key (NICKNAME)
  SQL> quit;


Awesome, the view now includes the C<twitter> column. But can we revert?

  > sqitch -d /home/fbdb/flipr_test.fdb revert --to @HEAD^ -y
  Reverting changes to hashtags @v1.0.0-dev2 from flipr_test.db
    - userflips .. ok

Did that work, is the C<twitter> column gone?

  > /opt/firebird/bin/isql -u SYSDBA -p <mysecret>
  Use CONNECT or CREATE DATABASE to specify a database
  SQL>  connect '/home/fbdb/flipr_test.fdb';
  Database:  '/home/fbdb/flipr_test.fdb', User: SYSDBA
  SQL>  show view userflips;
  ID                              INTEGER Not Null
  NICKNAME                        VARCHAR(50) Not Null
  FULLNAME                        VARCHAR(512) Not Null
  BODY                            VARCHAR(512) Not Null
  TIMESTMP                        TIMESTAMP Nullable
  View Source:
  ==== ======

    SELECT f.id, u.nickname, u.fullname, f.body, f.timestmp
        FROM users u
        JOIN flips f ON u.nickname = f.nickname
  SQL> quit;

Yes, it works! Sqitch properly finds the original instances of these changes
in the new script files that include tags.

Excellent. Let's go ahead and commit these changes:

  > git add .
  > git ci -m 'Add the twitter column to the userflips view.'
  [master 23b46a8] Add the twitter column to the userflips view.
   7 files changed, 40 insertions(+), 4 deletions(-)
   create mode 100644 deploy/userflips@v1.0.0-dev2.sql
   create mode 100644 revert/userflips@v1.0.0-dev2.sql
   create mode 100644 verify/userflips@v1.0.0-dev2.sql

=head1 More to Come

Sqitch is a work in progress. Better integration with version control systems
is planned to make managing idempotent reworkings even easier. Stay tuned.

=head1 Author

David E. Wheeler <david@justatheory.com>

=head1 License

Copyright (c) 2012-2013 iovation Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

=cut
