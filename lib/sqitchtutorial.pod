=head1 Name

sqitchtutorial - A tutorial introduction to Sqitch

=head1 Synopsis

  sqitch *

=head1 Description

This tutorial explains how to create a sqitch-enabled project, use a VCS for
deployment planning, and work with other developers to make sure changes
remain in sync and in the proper order.

We'll start with a new project, from scratch, a fictional antisocial
networking site called Flipr. All examples use L<Git|http://git-scm.com/> as
the VCS and L<PostgreSQL|http://www.postgresql.org/> as the storage engine,
but for the most part you can substitute other VCSes and database engines in
the examples as appropriate.

=head1 Starting a New Project

Usually the first thing to do when starting a new project is to create a
source code repository. So let's do that with Git:

  > mkdir flipr
  > cd flipr 
  > git init .
  Initialized empty Git repository in /flipr/.git/
  > touch README.md
  > git add .
  > git commit -am 'Fist post!'

If you're a Git user and want to follow along the history, the repository
used in these examples is L<on GitHub|https://github.com/theory/sqitch-intro>.

Now that we have a repository, let's get started with Sqitch.

  > sqitch init --engine pg
  Created sqitch.ini
  Created sql/deploy
  Created sql/revert

Let's have a look at F<sqitch.ini>:

  [core]
      engine      = pg
      # sql_dir   = sql
      # extension = sql

Pretty simple. It picked up on the fact that we're creating changes for the
PostgreSQL engine, thanks to the C<--engine pg> option, and saved it to the
file. By default, Sqitch will read F<sqitch.ini> in the current directory for
settings. But it will also read F<~/.sqitch/config.ini> for global settings.
Since PostgreSQL's C<psql> client is not in the path on my system, let's go
ahead an tell it globally where to find the client:

  sqitch config --global core.pg.client /var/lib/pgsql/bin/psql

Have a look at F<~/.sqitch/config.ini> and you'll see this:

  [core.pg]
      client = /var/lib/pgsql/bin/psql

Back to the repository. Let's commit these changes and start creating the
database changes.

  > git add .
  > git commit -am 'Initialize Sqitch configuration.'

=head1 Your First Deployment

First, our project will need a database user. This is the application user,
who will have only limited access to objects in the database. Run this command:

  > sqitch add-step appuser
  Adding sql/deploy/appuser.sql
  Adding sql/revert/appuser.sql

Now we can edit these files. The C<deploy> script's job is to create the user.
So add this to the file:

  CREATE ROLE flipr WITH LOGIN;

The C<revert> script's job is to precisely revert the change to the deploy
script, like so:

  DROP ROLE flipr;

Now we can try deploying this change:

  > sqitch --db-name flipr_test deploy --untracked
  Adding metadata schema to flipr_test
  Deploying HEAD+ to flipr_test
    - appuser

First Sqitch created the metadata schema it uses to track database changes.
The structure and name of the metadata may vary between databases (PostgreSQL
uses a schema to namespace its metadata; MySQL and SQLite use a prefix). Then
it deploys changes. Here it is deploying to something called C<HEAD+>.
Normally you would see a tag here, but since we've just added the files and
they are not yet committed to Git, there is no tag. C<HEAD+> is a special tag
reserved for use by Sqitch. It's enabled only by the use of the C<--untracked>
option, which allows Sqitch to find an deploy untracked changes.

With this change deployed, if you connect to the database, you'll be able to
see the role:

  > psql -d flipr_test -c '\du'
                                  List of roles
     Role name    |                   Attributes                   | Member of 
  ----------------+------------------------------------------------+-----------
   flipr          |                                                | {}
   postgres       | Superuser, Create role, Create DB, Replication | {}

And we can also see how the deployment was recorded via the C<status> command,
which reads the metadata tables from the database:

  > sqitch -d flipr_test status
  # Deployed to HEAD+
  # Step: appuser
  # Date: 2012-04-09 18:43:45
  #
  Nothing to deploy (up-to-date)

Let's make sure that we can revert the change, as well:

  > sqitch --db-name flipr_test revert
  Reverting all changes from flipr_test
    - appuser

And now the user should be gone:

  > psql -d flipr_test -c '\du'
                                  List of roles
     Role name    |                   Attributes                   | Member of 
  ----------------+------------------------------------------------+-----------
   postgres       | Superuser, Create role, Create DB, Replication | {}

And the status message should reflect as much:

  > sqitch -d flipr_test status --untracked
  # Nothing deployed.
  #
  # Changes not yet deployed:
  # * HEAD+
  #   appuser
  #
  Use "sqitch deploy" to deploy these changes

We've again used the C<--untracked> option, otherwise the C<appuser> step would
not appear in the list of undeployed changes.

We still have a record that the change happened, visible via the C<log>
command:

  > sqitch -d flipr_test log
  step appuser reverted
  By: david
  At: 2012-04-09 18:45:47
  Tag: HEAD+

  step appuser deployed
  By: david
  At: 2012-04-09 18:43:45
  Tag: HEAD+

Cool. Now let's commit it.

  > git add .
  > git commit -m 'Add app user.'
  [master 36acafd] Add app user.
   2 files changed, 2 insertions(+)
   create mode 100644 sql/deploy/appuser.sql
   create mode 100644 sql/revert/appuser.sql

And then deploy again:

  > sqitch --db-name flipr_test deploy
  Deploying 36acafd to flipr_test
    - appuser

Notice we no longer need the C<--untracked> option. That's because we've committed
the step to Git, so Sqitch can read it from the Git history. And now the user
should be back:

  > psql -d flipr_test -c '\du'
                                  List of roles
     Role name    |                   Attributes                   | Member of 
  ----------------+------------------------------------------------+-----------
   flipr          |                                                | {}
   postgres       | Superuser, Create role, Create DB, Replication | {}

When we look at the status, the deployment is tagged with the SHA1 of the
commit:

  > sqitch -d flipr_test status
  # Deployed to 36acafd
  # Step: appuser
  # Date: 2012-04-09 18:52:42
  #
  Nothing to deploy (up-to-date)

=head1 Deploy with Dependency

Let's add another deployment, this time to create a table. Our app will need
users, of course, so we'll create a table for them. First, add the new step:

  > sqitch add-step users
  Adding sql/deploy/users.sql
  Adding sql/revert/users.sql

Now edit the scripts. In C<sql/deploy/users.sql>, we put:

  -- requires: appuser
  BEGIN;
  SET client_min_messages = 'warning';

  CREATE TABLE users (
      nickname  TEXT        PRIMARY KEY,
      password  TEXT        NOT NULL,
      timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
  );

  GRANT SELECT ON users TO flipr;
  COMMIT;

A few things to notice here. On the first line, we've declared a dependency on
the C<appuser> step. Although the step has already been added and committed,
and therefore should always be applied before the C<users> step, it's a good
idea to always be explicit about dependencies on other steps. This becomes
especially important when committing a number of steps at one time, such as
when merging a patch or a branch.

The syntax of the dependency declaration is simple: Before any other lines,
create an SQL C<--> comment that simply uses the word "requires" followed by a
colon and then a comma-delimited list of required steps. The requirements may
also be listed on separate lines, providing they all start with
C<-- requires:>.

Notice that all of the SQL code is wrapped in a transaction. This is handy for
PostgreSQL deployments, because DDLs are transactional. The upshot is that if
any part of the deployment fails, the whole step fails. Such may work
less-well for database engines that don't support transactional DDLs.

Just before the commit, the C<GRANT> command grants C<SELECT> access on the
table to the C<flipr> user created in the C<appuser> step. This is why we
needed to declare the dependency.

Now for the revert script. Add this to C<sql/revert/users.sql>:

  DROP TABLE users;

Couldn't be much simpler, right? Let's deploy this bad boy:

  > sqitch --db-name flipr_test deploy --untracked
  Deploying HEAD+ to flipr_test
    - users

The C<users> table should have been created:

  > psql -d flipr_test -c '\d users'
                       Table "public.users"
    Column   |           Type           |       Modifiers        
  -----------+--------------------------+------------------------
   nickname  | text                     | not null
   password  | text                     | not null
   timestamp | timestamp with time zone | not null default now()
  Indexes:
      "users_pkey" PRIMARY KEY, btree (nickname)

Now have a look at the status:

  > sqitch -d flipr_test status
  # Deployed to HEAD+
  # Step: users
  # Date: 012-04-09 20:41:31
  #
  Nothing to deploy (up-to-date)

Success! However, we've once again deployed an untracked change with no tags.
In general, we want tags, so let's revert the change:

  > sqitch --db-name flipr_test revert --to 36acafd
  Reverting HEAD+ from flipr_test
  - users

Note that we've used the C<--to> option to revert only to the C<36acafd> tag,
which represents the deployment of the C<appuser> step (visible via
C<sqitch log>). Now commit and deploy again:

  > git add .
  > git commit -am 'Add users table.'
  [master fa650af] Add users table.
   2 files changed, 16 insertions(+)
   create mode 100644 sql/deploy/users.sql
   create mode 100644 sql/revert/users.sql
  > sqitch -d flipr_test deploy
  Deploying fa650af to flipr_test
    - users

Looks good. Check the status:

  > sqitch status --show tags
  # Deployed to fa650af
  # Step: users
  # Date: 012-04-09 20:45:23
  #
  # Tags:
  #    fa650af - 2012-04-09 20:45:23 - david
  #    36acafd - 2012-04-09 19:04:50 - david
  #
  Nothing to deploy (up-to-date)

Note the use of C<--show tags>, which adds the "Tags" section to the output,
so that we can se a list of what tags were deployed, when, and by whom.

=head1 Add Two at Once

Let's add a few more deployments that add functions for managing users.

  > sqitch add-step insert_user --requires users --requires appuser
  Adding sql/deploy/insert_user.sql
         -- requires: users, appuser
  Adding sql/revert/insert_user.sql

  > sqitch add-step change_pass --requires users --requires appuser
  Adding sql/deploy/change_pass.sql
         -- requires: users, appuser
  Adding sql/revert/change_pass.sql

Here we've taken advantage of the C<--requires> option to have Sqitch write
the deploy file with the C<-- requires:> line already filled in. Have a look:

  > cat sql/deploy/insert_user.sql
  -- requires: users, appuser
  

Nice, huh? Yeah, okay, so it's a little thing. Little things matter, no? Let's
write the code. Here's what C<sql/deploy/insert_user.sql> should look like:

  -- requires: users, appuser
  
  BEGIN;

  CREATE OR REPLACE FUNCTION insert_user(
      nickname TEXT,
      password TEXT
  ) RETURNS VOID LANGUAGE SQL SECURITY DEFINER AS $$
      INSERT INTO users values($1, md5($2));
  $$;

  GRANT EXECUTE ON insert_user(TEXT, TEXT) to flipr;
  COMMIT;

And C<sql/revert/insert_user.sql> should look something like this:

  DROP FUNCTION insert_user(TEXT, TEXT);

Now for C<change_pass>; C<sql/deploy/change_pass.sql> might look like this:

  -- requires: users, appuser

  BEGIN;

  CREATE OR REPLACE FUNCTION change_pass(
      nick    TEXT,
      oldpass TEXT,
      newpass TEXT
  ) RETURNS BOOLEAN LANGUAGE plpgsql AS $$
  BEGIN
      UPDATE users
         SET password = md5($3)
       WHERE nickname = $1
         AND password = md5($2);
      RETURN FOUND;
  END;
  $$;

  GRANT EXECUTE ON chnage_pass(TEXT, TEXT, TEXT) to flipr;
  COMMIT;

And of course, its reversion script, C<sql/revert/change_pass.sql> should look
something like:

  DROP FUNCTION change_pass(TEXT, TEXT, TEXT);

Test em out!

  > sqitch --db-name flipr_test deploy --untracked
  Deploying HEAD+ to flipr_test
    - change_pass
    - insert_user

Do we have the functions?

  > psql -d flipr_test -c '\df'
                                      List of functions
   Schema |    Name     | Result data type |          Argument data types          |  Type  
  --------+-------------+------------------+---------------------------------------+--------
   public | change_pass | boolean          | nick text, oldpass text, newpass text | normal
   public | insert_user | void             | nickname text, password text          | normal

Is the state set properly?

  > psql -d flipr_test -c 'SELECT * FROM sqitch.state ORDER BY deployed_at'
      step     | deployed_by |   tags    |    requires     | conflicts |          deployed_at          
  -------------+-------------+-----------+-----------------+-----------+-------------------------------
   appuser     | david       | {36acafd} | {}              | {}        | 2012-04-09 19:04:50.115235+00
   users       | david       | {fa650af} | {appuser}       | {}        | 2012-04-09 20:45:23.848563+00
   change_pass | david       | {""}      | {appuser,users} | {}        | 2012-04-09 21:31:41.952779+00
   insert_user | david       | {""}      | {appuser,users} | {}        | 2012-04-09 21:31:42.137245+00

Looks good. Let's revert, commit, and re-deploy, as usual.

  > sqitch --db-name flipr_test revert --to ^
  Reverting HEAD+ from flipr_test
    - insert_user
    - change_pass

Note the use of C<--to ^> to revert one tag. We also could have explicitly
used C<--to fa650af> to revert to that tag, but C<^> is a nice shortcut.
(Technially, it's actually C<""^>, which means "before the C<""> tag." But
don't let that bother you.). Let's do the commit and re-deploy dance:

  > git add .
  > git ci -m 'Add `insert_user()` and `change_pass()`.'
  [master 803e6b8] Add `insert_user()` and `change_pass()`.
   4 files changed, 25 insertions(+)
   create mode 100644 sql/deploy/change_pass.sql
   create mode 100644 sql/deploy/insert_user.sql
   create mode 100644 sql/revert/change_pass.sql
   create mode 100644 sql/revert/insert_user.sql

  > sqitch --db-name flipr_test deploy
  Deploying 803e6b8 to flipr_test
    - change_pass
    - insert_user

  > psql -d flipr_test -c 'SELECT * FROM sqitch.state ORDER BY deployed_at'
      step     | deployed_by |   tags    |    requires     | conflicts |          deployed_at          
  -------------+-------------+-----------+-----------------+-----------+-------------------------------
   appuser     | david       | {36acafd} | {}              | {}        | 2012-04-09 19:04:50.115235+00
   users       | david       | {fa650af} | {appuser}       | {}        | 2012-04-09 20:45:23.848563+00
   change_pass | david       | {803e6b8} | {appuser,users} | {}        | 2012-04-09 21:33:32.385953+00
   insert_user | david       | {803e6b8} | {appuser,users} | {}        | 2012-04-09 21:33:32.830234+00

=head1 Ship It!

Let's do a first release of our app. Let's call it C<1.0.0-dev1> Since we want
to have it go out with deployments tied to the release, let's tag it:

  > git tag v1.0.0-dev1 -am 'Tag v1.0.0-dev1'

We can test deployment to make sure the tag gets picked up like so:

  > createdb flipr_dev
  > sqitch --db-name flipr_dev deploy
  Deploying 36acafd/v1.0.0-dev1 to flipr_dev
    - appuser
  Deploying fa650af/v1.0.0-dev1 to flipr_dev
    - users
  Deploying 803e6b8/v1.0.0-dev1 to flipr_dev
    - insert_user
    - change_pass

All four steps were deployed, great! Let's have a look at the state:

  > psql -d flipr_dev -c 'SELECT * FROM sqitch.state ORDER BY deployed_at'
      step     | deployed_by |         tags          |    requires     | conflicts |          deployed_at          
  -------------+-------------+-----------------------+-----------------+-----------+-------------------------------
   appuser     | david       | {36acafd,v1.0.0-dev1} | {}              | {}        | 2012-04-09 22:13:53.383434+00
   users       | david       | {fa650af,v1.0.0-dev1} | {appuser}       | {}        | 2012-04-09 22:13:55.594923+00
   insert_user | david       | {803e6b8,v1.0.0-dev1} | {appuser,users} | {}        | 2012-04-09 22:13:59.253434+00
   change_pass | david       | {803e6b8,v1.0.0-dev1} | {appuser,users} | {}        | 2012-04-09 22:14:00.854345+00

Note that teach step now has the commit SHA1 for a tag I<and> the
C<v1.0.0-dev1> tag. This is great, because now we can tie all the steps to the
release via the tag. So let's bundle it up.

  > sqitch bundle --tags-only
  Writint to in bundle/
  Bundling v1.0.0-dev1
    - appuser
    - users
    - change_pass
    - insert_user
  Plan written to bundle/sqitch.plan

Now you can package up the C<bundle> directory and distribute it. When it gets
installed somewhere, you can use Sqitch to deploy to the database. Of course,
the Git history is no longer available, so Sqitch will use the C<sqitch.plan>
file to figure things out. Let's have a look at it:

  cat bundle/sqitch.plan

  [v1.0.0-dev1]
  appuser
  users
  change_pass
  insert_user

Pretty simple. It shows the tag being deployed and the steps that constitute
it as a simple list. Notice that the SHA1s for each step are not present; the
C<--tags-only> option to the C<bundle> command limits the plan only to tags.

Let's test deploying it:

  > cd bundle
  > createdb flipr_prod
  > sqitch --db-name flipr_prod deploy
  Deploying v1.0.0-dev1 to flipr_prod
    - appuser
    - users
    - insert_user
    - change_pass

Looks much the same as before, eh? But have a look at the state:

  > psql -d flipr_prod -c 'SELECT * FROM sqitch.state ORDER BY deployed_at'
      step     | deployed_by |     tags      |    requires     | conflicts |          deployed_at          
  -------------+-------------+---------------+-----------------+-----------+-------------------------------
   appuser     | david       | {v1.0.0-dev1} | {}              | {}        | 2012-04-09 22:17:23.934343+00
   users       | david       | {v1.0.0-dev1} | {appuser}       | {}        | 2012-04-09 22:17:25.343254+00
   insert_user | david       | {v1.0.0-dev1} | {appuser,users} | {}        | 2012-04-09 22:17:36.235544+00
   change_pass | david       | {v1.0.0-dev1} | {appuser,users} | {}        | 2012-04-09 22:17:38.377565+00

No SHA1 tags, just C<v1.0.0-dev1>.
